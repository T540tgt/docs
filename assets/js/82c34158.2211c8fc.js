"use strict";(self.webpackChunkdocs_oasis_io=self.webpackChunkdocs_oasis_io||[]).push([[9737],{4271:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var i=t(4848),a=t(8453);const s={description:"Authenticate users with your confidential contracts"},r="View-Call Authentication",c={id:"dapp/sapphire/authentication",title:"View-Call Authentication",description:"Authenticate users with your confidential contracts",source:"@site/docs/dapp/sapphire/authentication.md",sourceDirName:"dapp/sapphire",slug:"/dapp/sapphire/authentication",permalink:"/dapp/sapphire/authentication",draft:!1,unlisted:!1,editUrl:"https://github.com/oasisprotocol/sapphire-paratime/edit/main/docs/authentication.md",tags:[],version:"current",lastUpdatedAt:1723018842e3,frontMatter:{description:"Authenticate users with your confidential contracts"},sidebar:"developers",previous:{title:"Browser Support",permalink:"/dapp/sapphire/browser"},next:{title:"Gasless Transactions",permalink:"/dapp/sapphire/gasless"}},o={},d=[{value:"Sapphire Wrapper",id:"sapphire-wrapper",level:2},{value:"Caching Signed Queries",id:"caching-signed-queries",level:2},{value:"Daily Sign-In with EIP-712",id:"daily-sign-in-with-eip-712",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"view-call-authentication",children:"View-Call Authentication"}),"\n",(0,i.jsxs)(n.p,{children:['User impersonation on Ethereum and other "Transparent EVMs" isn\'t a problem\nbecause ',(0,i.jsx)(n.strong,{children:"everybody"})," can see ",(0,i.jsx)(n.strong,{children:"all"})," data however the Sapphire confidential\nEVM prevents contracts from revealing confidential information to the wrong\nparty (account or contract) - for this reason we cannot allow arbitrary\nimpersonation of any ",(0,i.jsx)(n.code,{children:"msg.sender"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In Sapphire, there are four types of contract calls:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Contract to contract calls (also known as ",(0,i.jsx)(n.em,{children:"internal calls"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Unauthenticted view calls (queries using ",(0,i.jsx)(n.code,{children:"eth_call"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Authenticated view calls (signed queries)"}),"\n",(0,i.jsx)(n.li,{children:"Transactions (authenticated by signature)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Intra-contract calls always set ",(0,i.jsx)(n.code,{children:"msg.sender"})," appropriately, if a contract calls\nanother contract in a way which could reveal sensitive information, the calling\ncontract must implement access control or authentication."]}),"\n",(0,i.jsxs)(n.p,{children:["By default all ",(0,i.jsx)(n.code,{children:"eth_call"})," queries used to invoke contract functions have the\n",(0,i.jsx)(n.code,{children:"msg.sender"})," parameter set to ",(0,i.jsx)(n.code,{children:"address(0x0)"}),". In contrast, authenticated calls are\nsigned by a keypair and will have the ",(0,i.jsx)(n.code,{children:"msg.sender"})," parameter correctly initialized\n(more on that later). Also, when a transaction is\nsubmitted it is signed by a keypair (thus costs gas and can make state updates)\nand the ",(0,i.jsx)(n.code,{children:"msg.sender"})," will be set to the signing account."]}),"\n",(0,i.jsx)(n.h2,{id:"sapphire-wrapper",children:"Sapphire Wrapper"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/@oasisprotocol/sapphire-paratime",children:"@oasisprotocol/sapphire-paratime"})," Ethereum provider wrapper\n",(0,i.jsx)(n.code,{children:"sapphire.wrap"})," function will ",(0,i.jsx)(n.strong,{children:"automatically end-to-end encrypt calldata"})," when\ninteracting with contracts on Sapphire, this is an easy way to ensure the\ncalldata of your dApp transactions remain confidential - although the ",(0,i.jsx)(n.code,{children:"from"}),",\n",(0,i.jsx)(n.code,{children:"to"}),", and ",(0,i.jsx)(n.code,{children:"gasprice"})," parameters are not encrypted."]}),"\n",(0,i.jsx)(n.admonition,{title:"Unauthenticated calls and Encryption",type:"tip",children:(0,i.jsx)(n.p,{children:"Although the calls may be unauthenticated, they can still be encrypted!"})}),"\n",(0,i.jsxs)(n.p,{children:["However, if the Sapphire wrapper has been attached to a signer then subsequent\nview calls via ",(0,i.jsx)(n.code,{children:"eth_call"})," will request that the user sign them (e.g. a\nMetaMask popup), these are called ",(0,i.jsx)(n.strong,{children:"signed queries"})," meaning ",(0,i.jsx)(n.code,{children:"msg.sender"})," will be\nset to the signing account and can be used for authentication or to implement\naccess control. This may add friction to the end-user experience and can result\nin frequent pop-ups requesting they sign queries which wouldn't normally require\nany interaction on Transparent EVMs."]}),"\n",(0,i.jsx)(n.p,{children:"Let's see how Sapphire interprets different contract calls. Suppose the\nfollowing solidity code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"contract Example {\n    address owner;\n    constructor () {\n        owner = msg.sender;\n    }\n    function isOwner () public view returns (bool) {\n        return msg.sender == owner;\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the sample above, assuming we're calling from the same contract or account\nwhich created the contract, calling ",(0,i.jsx)(n.code,{children:"isOwner"})," will return:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"false"}),", for ",(0,i.jsx)(n.code,{children:"eth_call"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"false"}),", with ",(0,i.jsx)(n.code,{children:"sapphire.wrap"})," but without an attached signer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"true"}),", with ",(0,i.jsx)(n.code,{children:"sapphire.wrap"})," and an attached signer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"true"}),", if called via the contract which created it"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"true"}),", if called via transaction"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"caching-signed-queries",children:"Caching Signed Queries"}),"\n",(0,i.jsx)(n.p,{children:"When using signed queries the blockchain will be queried each time, however\nthe Sapphire wrapper will cache signatures for signed queries with the same\nparameters to avoid asking the user to sign the same thing multiple times."}),"\n",(0,i.jsxs)(n.p,{children:['Behind the scenes the signed queries use a "leash" to specify validity conditions\nso the query can only be performed within a block and account ',(0,i.jsx)(n.code,{children:"nonce"})," range.\nThese parameters are visible in the EIP-712 popup signed by the user. Queries\nwith the same parameters will use the same leash."]}),"\n",(0,i.jsx)(n.h2,{id:"daily-sign-in-with-eip-712",children:"Daily Sign-In with EIP-712"}),"\n",(0,i.jsxs)(n.p,{children:["One strategy which can be used to reduce the number of transaction signing\nprompts when a user interacts with contracts via a dApp is to use\n",(0,i.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-712",children:"EIP-712"}),' to "sign-in" once per day (or per-session), in combination\nwith using two wrapped providers:']}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Provider to perform encrypted but unauthenticated view calls"}),"\n",(0,i.jsxs)(n.li,{children:["Another provider to perform encrypted and authenticated transactions (or view calls)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The user will be prompted to sign each action."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The two-provider pattern, in conjunction with a daily EIP-712 sign-in prompt\nensures all transactions are end-to-end encrypted and the contract can\nauthenticate users in view calls without frequent annoying popups."}),"\n",(0,i.jsxs)(n.p,{children:["The code sample below uses an ",(0,i.jsx)(n.code,{children:"authenticated"})," modifier to verify the sign-in:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nstruct SignatureRSV {\n    bytes32 r;\n    bytes32 s;\n    uint256 v;\n}\n\ncontract SignInExample {\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    string public constant SIGNIN_TYPE = "SignIn(address user,uint32 time)";\n    bytes32 public constant SIGNIN_TYPEHASH = keccak256(bytes(SIGNIN_TYPE));\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    constructor () {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            EIP712_DOMAIN_TYPEHASH,\n            keccak256("SignInExample.SignIn"),\n            keccak256("1"),\n            block.chainid,\n            address(this)\n        ));\n    }\n\n    struct SignIn {\n        address user;\n        uint32 time;\n        SignatureRSV rsv;\n    }\n\n    modifier authenticated(SignIn calldata auth)\n    {\n        // Must be signed within 24 hours ago.\n        require( auth.time > (block.timestamp - (60*60*24)) );\n\n        // Validate EIP-712 sign-in authentication.\n        bytes32 authdataDigest = keccak256(abi.encodePacked(\n            "\\x19\\x01",\n            DOMAIN_SEPARATOR,\n            keccak256(abi.encode(\n                SIGNIN_TYPEHASH,\n                auth.user,\n                auth.time\n            ))\n        ));\n\n        address recovered_address = ecrecover(\n            authdataDigest, uint8(auth.rsv.v), auth.rsv.r, auth.rsv.s);\n\n        require( auth.user == recovered_address, "Invalid Sign-In" );\n\n        _;\n    }\n\n    function authenticatedViewCall(\n        SignIn calldata auth,\n        ... args\n    )\n        external view\n        authenticated(auth)\n        returns (bytes memory output)\n    {\n        // Use `auth.user` instead of `msg.sender`!\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"With the above contract code deployed, let's look at the frontend dApp and how\nit can request the user to sign-in using EIP-712. You may wish to add additional\nparameters which are authenticated such as the domain name. The following code\nexample uses Ethers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const time = new Date().getTime();\nconst user = await eth.signer.getAddress();\n\n// Ask user to "Sign-In" every 24 hours.\nconst signature = await eth.signer.signTypedData({\n    name: "SignInExample.SignIn",\n    version: "1",\n    chainId: import.meta.env.CHAINID,\n    verifyingContract: await contract.getAddress()\n}, {\n    SignIn: [\n        { name: \'user\', type: "address" },\n        { name: \'time\', type: \'uint32\' },\n    ]\n}, {\n    user,\n    time: time\n});\nconst rsv = ethers.Signature.from(signature);\nconst auth = {user, time, rsv};\n// The `auth` variable can then be cached.\n\n// Then in the future, authenticated view calls can be performed by\n// passing auth without further user interaction authenticated data.\nawait contract.authenticatedViewCall(auth, ...args);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);